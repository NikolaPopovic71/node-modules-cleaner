#!/usr/bin/env python3
"""
Clean node_modules folders from a zip archive.
Extracts the zip, removes all node_modules directories, and creates a new cleaned zip.
"""

import zipfile
import shutil
import tempfile
from pathlib import Path
import argparse

def remove_node_modules(directory):
    """
    Recursively find and remove all node_modules folders.
    Returns the number of folders removed and space freed.
    """
    removed_count = 0
    total_size = 0
    
    directory_path = Path(directory)
    
    # Find all node_modules directories
    for node_modules_path in directory_path.rglob('node_modules'):
        if node_modules_path.is_dir():
            # Calculate size before deletion
            folder_size = sum(f.stat().st_size for f in node_modules_path.rglob('*') if f.is_file())
            total_size += folder_size
            
            print(f"Removing: {node_modules_path} ({folder_size / (1024*1024):.2f} MB)")
            shutil.rmtree(node_modules_path)
            removed_count += 1
    
    return removed_count, total_size

def clean_zip(input_zip_path, output_zip_path=None):
    """
    Clean node_modules from a zip file.
    
    Args:
        input_zip_path: Path to the input zip file
        output_zip_path: Path for the output cleaned zip (optional)
    """
    input_zip = Path(input_zip_path)
    
    if not input_zip.exists():
        raise FileNotFoundError(f"Input zip file not found: {input_zip_path}")
    
    # If no output path specified, create one with _cleaned suffix
    if output_zip_path is None:
        output_zip_path = input_zip.parent / f"{input_zip.stem}_cleaned.zip"
    
    print(f"Input zip: {input_zip_path}")
    print(f"Output zip: {output_zip_path}")
    print(f"Original size: {input_zip.stat().st_size / (1024*1024):.2f} MB\n")
    
    # Create a temporary directory for extraction
    with tempfile.TemporaryDirectory() as temp_dir:
        print("Extracting zip file...")
        with zipfile.ZipFile(input_zip_path, 'r') as zip_ref:
            zip_ref.extractall(temp_dir)
        
        print("Extraction complete.\n")
        
        # Remove node_modules folders
        print("Searching for node_modules folders...")
        removed_count, total_size = remove_node_modules(temp_dir)
        
        print(f"\nRemoved {removed_count} node_modules folder(s)")
        print(f"Space freed: {total_size / (1024*1024):.2f} MB\n")
        
        # Create new zip without node_modules
        print("Creating cleaned zip file...")
        with zipfile.ZipFile(output_zip_path, 'w', zipfile.ZIP_DEFLATED) as zip_out:
            temp_path = Path(temp_dir)
            for file_path in temp_path.rglob('*'):
                if file_path.is_file():
                    arcname = file_path.relative_to(temp_dir)
                    zip_out.write(file_path, arcname)
        
        output_size = Path(output_zip_path).stat().st_size
        print(f"Cleaned zip created: {output_zip_path}")
        print(f"New size: {output_size / (1024*1024):.2f} MB")
        print(f"Size reduction: {(input_zip.stat().st_size - output_size) / (1024*1024):.2f} MB")

def main():
    parser = argparse.ArgumentParser(
        description='Clean node_modules folders from a zip archive',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s projects.zip
  %(prog)s projects.zip -o clean_projects.zip
        """
    )
    
    parser.add_argument('input_zip', help='Path to the input zip file')
    parser.add_argument('-o', '--output', help='Path for the output cleaned zip (default: input_cleaned.zip)')
    
    args = parser.parse_args()
    
    try:
        clean_zip(args.input_zip, args.output)
        print("\n✓ Cleaning completed successfully!")
    except Exception as e:
        print(f"\n✗ Error: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())
